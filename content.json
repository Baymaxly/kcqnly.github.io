{"pages":[{"title":"categories","text":"","link":"/categories/index.html"}],"posts":[{"title":"WebREPL","text":"WebREPL客户端是MicroPython官方推荐的更新方式，功能很强大，通过网页的方式读取ESP8266/ESP32的文件系统，可以上传文件或者下载开发板中已存在的文件，可以输入指令并实时查看开发板中的输出状态，完全取代串口调试。配置完就再也不用把8266连接到电脑来写代码了，基本上就可以闲置了。 使用官方的WebREPL(以ESP8266为例) NodeMCU ESP8266*1 uPyCraft V1.1 WIFI关于ESP8266不能连接校园网的问题，可以选择打开手机热点，或者连接ESP8266发出的wifi信号，之后也会出一篇用树莓派当路由器的文章，喜欢折腾的，也可以试一试。让8266连接网络 在repl中打开WebREPL1234567891011&gt;&gt;&gt; import webrepl_setupWebREPL daemon auto-start status: disabledWould you like to (E)nable or (D)isable it running on boot?(Empty line to quit)&gt; ETo enable WebREPL, you must set password for itNew password: 你的密码Confirm password: 你的密码Changes will be activated after rebootWould you like to reboot now? (y/n) 还得再输入两条语句这里有两个ip地址，如果你是直接连的ESP8266发出的WIFI信号的话，那么就是上面一个，如果你连的是自己的wifi，那么就是下面一个 通过网页访问ESP8266WebREPL客户端必须与开发板处在同一局域网下，否则无法正常连接官方webrepl网址输入 ws://192.168.1.136:8266再输入之前设置的密码，就ok了 一些常用指令我们可以看到WebREPL网页右端有上传和下载文件的按钮，我们可以通过这些按钮来把我们本地写的代码上传到8266，但是上传之后怎么运行呢，怎么删除上传的错误文件？下面就是一些常用的指令12345exec(open('main.py').read()) #执行main.py这个文件import osos.remove(\"test.py\") #删除test.py这个文件os.listdir() #列出主目录下的所有文件 遗留问题把连网和打开WebREPL的代码放到boot.py这个文件里，就可以上电自动运行，但是，这样就带来了一个问题，那就是ESP8266的IP会变，每次还得去查IP，也是挺烦的，查了一下官方手册，貌似是没有设置静态IP的方法。。。。。。 害 吐槽一下，官方的页面好丑，最近发现了一个国内的WebREPL，还挺好的，尝试了一下，由于ESP8266内存有限，用不了，准备用ESP32试一试 EMP-IDE 感谢阅读","link":"/2019/10/27/WebREPL/"},{"title":"CentOS7安装jdk12","text":"卸载openjdk查找已安装的java包1rpm -qa | grep java 删除已安装的java1234rpm -e --nodeps java-1.8.0-openjdk-1.8.0.102-4.b14.el7.x86_64rpm -e --nodeps java-1.8.0-openjdk-headless-1.8.0.102-4.b14.el7.x86_64rpm -e --nodeps java-1.7.0-openjdk-headless-1.7.0.111-2.6.7.8.el7.x86_64rpm -e --nodeps java-1.7.0-openjdk-1.7.0.111-2.6.7.8.el7.x86_64 下载JDK12压缩包 点击这里开始下载 安装创建安装目录1mkdir /usr/local/java/ 上传文件至安装目录1rz 然后选择要上传的文件如果有xftp，那就更方便了 解压至安装目录1tar -xzvf jdk-12.0.2-linux-x64-bin.tar.gz -C /usr/local/java/ 设置环境变量打开文件1vim /etc/profile 修改文件按i进入编辑模式在末尾添加1234export JAVA_HOME=/usr/local/java/jdk12.0.2export JRE_HOME=${JAVA_HOME}/jreexport CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/libexport PATH=${JAVA_HOME}/bin:$PATH 保存更改 Linux相关保存命令按ESC键 跳到命令模式，然后： :w 保存文件但不退出vi :w file 将修改另外保存到file中，不退出vi :w! 强制保存，不推出vi :wq 保存文件并退出vi :wq! 强制保存文件，并退出vi :q 不保存文件，退出vi :q! 不保存文件，强制退出vi :e! 放弃所有修改，从上次保存文件开始再编辑 1:wq 使环境变量生效1source /etc/profile 添加软链接1ln -s /usr/local/java/jdk12.0.2/bin/java /usr/bin/java 检查1java -version 删除压缩包12cd /rootrm -rf jdk-12.0.2-linux-x64-bin.tar.gz","link":"/2019/09/13/Centos7安装jdk12/"},{"title":"Git学习笔记","text":"1.在现有目录中初始化Git仓库 1git init 2.对文件的跟踪 1git add *.c 3.提交文件 12git commit -m \"message\"message为对本次提交的说明 4.掌握仓库当前的状态 1git status 5.查看不同 1git diff file-name 6.查看提交日志 1git log 7.版本回溯 1234git reset --hard HEAD^HEAD表示当前版本上一个版本就是HEAD^，上上一个版本就是HEAD^^当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。 8.查看命令历史 1234567git refloge475afc HEAD@{1}: reset: moving to HEAD^1094adb (HEAD -&gt; master) HEAD@{2}: commit: append GPLe475afc HEAD@{3}: commit: add distributedeaadf4e HEAD@{4}: commit (initial): wrote a readme file然后再使用git reset --hard 1094a就可以返回到append GPL的那个版本 9.丢弃工作区的修改 12git checkout -- filegit reset HEAD &lt;file&gt; 场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout – file。 场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD ，就回到了场景1，第二步按场景1操作。 场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。 10.删除文件 123git rm &lt;file&gt;# 如果误删了# 使用git checkout -- text.txt 可恢复 分支 123456git branch hexo 创建分支hexogit checkout hexo 切换到hexo分支git checkout -b hexo 创建并切换到hexo分支git merge hexo 将hexo分支合并到master分支git branch -d hexo 删除hexo分支git branch 查看分支 git push失败时的处理措施 报错 ! [rejected] master -&gt; master (fetch first)error: failed to push some refs to 你的仓库地址hint: Updates were rejected because the remote contains work that you dohint: not have locally. This is usually caused by another repository pushinghint: to the same ref. You may want to first integrate the remote changeshint: (e.g., ‘git pull …’) before pushing again.hint: See the ‘Note about fast-forwards’ in ‘git push –help’ for details. 解决措施1234git pull --rebase origin master# 先将远程文件同步，再推送git push origin master","link":"/2019/07/06/Git学习笔记/"},{"title":"JAVA UDP编程","text":"UDP:无连接无状态的通信协议 发送方发送数据，如果接收方刚好在原地，则可以接收数据。如果不在，那么信息将丢失 发送方无法得知是否发送成功 简单，节省，经济 相关类DatagramSocket:通讯的数据管道 send和receive方法 绑定一个IP和Port DatagramPacket 集装箱：封装数据 地址：目的地IP+Port 代码实现一、实现单方面发送和接收发送端123456789101112131415161718192021222324import java.net.*;import java.util.Scanner;public class UdpSend { public static void main(String[] args) throws Exception { DatagramSocket ds = new DatagramSocket(); Scanner in = new Scanner(System.in); while(true) { String str = in.nextLine(); DatagramPacket dp = new DatagramPacket(str.getBytes(), str.getBytes().length, InetAddress.getByName(\"127.0.0.1\"), 3000); /*如果用str.length(),会出现中文乱码的问题。 将数据装到DatagramPacket时,英文字符是一个占一个字节, 而一个中文字符是占据两个字节,所以发送数据的长度如果用sendStr.length()计算, 英文字符不会出错,计算中文字符就会少计算了要发送的总字节数, 造成UDP服务端接收中文乱码*/ ds.send(dp); System.out.println(\"发送成功\"); if(str.equals(\"bye\")) return ; } }} 接收端12345678910111213141516171819import java.net.*;public class UdpRecv { public static void main(String[] args) throws Exception { DatagramSocket ds = new DatagramSocket(3000); byte[] buf = new byte[1024]; DatagramPacket dp = new DatagramPacket(buf, 1024); String strRecv; do { System.out.println(\"UdpRecv: 我在等待信息\"); ds.receive(dp); System.out.println(\"UdpRecv: 我接收到信息\"); strRecv = new String(dp.getData(), 0, dp.getLength()); System.out.println(strRecv); }while(!strRecv.equals(\"bye\")); ds.close(); }} 二、实现双向传输发送端12345678910111213141516171819202122232425262728import java.net.*;public class UdpSend{ public static void main(String [] args) throws Exception { DatagramSocket ds=new DatagramSocket();//建立通信管道 Scanner in = new Scanner(System.in); String str=in.nextLine(); DatagramPacket dp=new DatagramPacket(str.getBytes(),str.getBytes().length, InetAddress.getByName(\"127.0.0.1\"),3000); //127.0.0.1代表本机 System.out.println(\"UdpSend: 我要发送信息\"); ds.send(dp); System.out.println(\"UdpSend: 我发送信息结束\"); Thread.sleep(1000); byte [] buf=new byte[1024]; DatagramPacket dp2=new DatagramPacket(buf,1024); System.out.println(\"UdpSend: 我在等待信息\"); ds.receive(dp2); System.out.println(\"UdpSend: 我接收到信息\"); String str2=new String(dp2.getData(),0,dp2.getLength()) + \" from \" + dp2.getAddress().getHostAddress()+\":\"+dp2.getPort(); System.out.println(str2); ds.close(); }} 接收端12345678910111213141516171819202122232425262728import java.net.*;public class UdpRecv{ public static void main(String[] args) throws Exception { DatagramSocket ds=new DatagramSocket(3000); byte [] buf=new byte[1024]; DatagramPacket dp=new DatagramPacket(buf,1024); Scanner in = new Scanner(System.in); System.out.println(\"UdpRecv: 我在等待信息\"); ds.receive(dp); System.out.println(\"UdpRecv: 我接收到信息\"); String strRecv=new String(dp.getData(),0,dp.getLength()) + \" from \" + dp.getAddress().getHostAddress()+\":\"+dp.getPort(); System.out.println(strRecv); Thread.sleep(1000); System.out.println(\"UdpRecv: 我要发送信息\"); String str=in.nextLine(); DatagramPacket dp2=new DatagramPacket(str.getBytes(),str.length(), InetAddress.getByName(\"127.0.0.1\"),dp.getPort()); ds.send(dp2); System.out.println(\"UdpRecv: 我发送信息结束\"); ds.close(); }} 感谢阅读","link":"/2019/08/24/Java-UDP/"},{"title":"更换电脑前后对原hexo博客的处理","text":"有时我们需要更换电脑或重装系统，这时就需要我们对hexo博客源文件进行备份 如果您不是很会用git,我建议您可以先选择用U盘拷贝，然后有时间的时候再好好学习一下git 一、 备份方法一 U盘拷贝并不是所有的文件都要拷贝，只需拷贝根目录下的 _config.yml package.json scaffolds/ source/ themes/ 方法二 分支管理 在本地先初始化git仓库 1git init 关联远程仓库1git remote add origin http://github.com/xxxxxx(你hexo博客的地址) 然后创建并切换到hexo分支1git checkout -b hexo 将文件放入暂存区，并推送到远程仓库 二、 安装hexo(别忘了安装Git和Node.js)鼠标右键Git Bash 输入 (以下指令皆在Git bash中输入)1npm install hexo-cli -g 三、 初始化文件夹1hexo init 然后将源文件直接复制过来方法二的朋友们就把指定分支上的文件clone下来就行1git clone -b 分支名 仓库地址 四、安装相应模块12npm instalnpm install hexo-deployer-git --save //将文章部署到git的模块 五、进行测试123hexo cleanhexo ghexo s 在浏览器输入http://localhost:4000 就能看到博客了 六、重新部署到GitHub上删除原先的SSH重新生成SSH添加到github就好了 12git config --global user.name &quot;yourname&quot;git config --global user.email &quot;youremail&quot; 用下面两个指令确认你有没有输对 12git config user.namegit config user.email 生成SSH(一路回车就OK) 1ssh-keygen -t rsa -C &quot;youremail&quot; 感谢阅读","link":"/2019/05/23/hexo-1/"},{"title":"Java-Mail","text":"之前做过的好几个项目都用到了JAVA发送邮件的功能，这里放出我用过的两种方法，其实现在只用第二种方法，hhh。 方法一 使用javax.mail包有一说一，这个真的捞，我之前用这个问题是真的多，windows上可以发，linux不能发……我是被这个折磨了好几晚 使用前先添加Maven依赖 123456&lt;!-- https://mvnrepository.com/artifact/javax.mail/mail --&gt;&lt;dependency&gt; &lt;groupId&gt;javax.mail&lt;/groupId&gt; &lt;artifactId&gt;mail&lt;/artifactId&gt; &lt;version&gt;1.4&lt;/version&gt;&lt;/dependency&gt; 上代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283import javax.mail.Message;import javax.mail.MessagingException;import javax.mail.Session;import javax.mail.Transport;import javax.mail.internet.AddressException;import javax.mail.internet.InternetAddress;import javax.mail.internet.MimeMessage;import java.util.Date;import java.util.Properties;public class MailSend { //发件人地址 private static String senderAddress = \"xxx@163.com\"; //收件人地址 private static String recipientAddress ; //发件人账户名（网易邮箱用户名） private static String senderAccount = \"xxx\"; //发件人账户密码(网易邮箱的授权码) private static String senderPassword = \"xxx\"; private Properties props; private Session session; public MailSend(String receive) { this.recipientAddress=receive; //1、连接邮件服务器的参数配置 props = System.getProperties(); //设置用户的认证方式 props.setProperty(\"mail.smtp.auth\", \"true\"); //设置传输协议 props.setProperty(\"mail.transport.protocol\", \"smtp\"); //设置发件人的SMTP服务器地址 props.setProperty(\"mail.smtp.host\", \"smtp.163.com\"); props.put(\"mail.smtp.ssl.enable\", true); //2、创建定义整个应用程序所需的环境信息的 Session 对象 session = Session.getInstance(props); } /** * 获得创建一封邮件的实例对象 * @param session * @return * @throws MessagingException * @throws AddressException */ public static MimeMessage getMimeMessage(Session session,String data) throws Exception{ //创建一封邮件的实例对象 MimeMessage msg = new MimeMessage(session); //设置发件人地址 msg.setFrom(new InternetAddress(senderAddress)); msg.setRecipient(MimeMessage.RecipientType.TO,new InternetAddress(recipientAddress)); //设置邮件主题 msg.setSubject(\"Hello\",\"UTF-8\"); msg.setText(data); //设置邮件的发送时间,默认立即发送 msg.setSentDate(new Date()); return msg; } public void sendMessage(String s) throws Exception { //3、创建邮件的实例对象 Message msg = getMimeMessage(session,s); //4、根据session对象获取邮件传输对象Transport Transport transport = session.getTransport(); //设置发件人的账户名和密码 transport.connect(senderAccount, senderPassword); //发送邮件，并发送到所有收件人地址，message.getAllRecipients() 获取到的是在创建邮件对象时添加的所有收件人, 抄送人, 密送人 transport.sendMessage(msg,msg.getAllRecipients()); //如果只想发送给指定的人，可以如下写法 //transport.sendMessage(msg, new Address[]{new InternetAddress(\"xxx@qq.com\")}); //5、关闭邮件连接 transport.close(); }} 这个捞的很，发送HTML语句会出问题，只能发纯文本，这根本不能满足个性化需求啊，难搞 还是看方法二吧使用apache.commons.mail包添加Maven依赖123456&lt;!-- https://mvnrepository.com/artifact/org.apache.commons/commons-email --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-email&lt;/artifactId&gt; &lt;version&gt;1.4&lt;/version&gt;&lt;/dependency&gt; 代码代码，来看代码12345678910111213141516171819202122232425262728293031import org.apache.commons.mail.EmailException;import org.apache.commons.mail.HtmlEmail;public class MailSend { public static void main(String[] args) { HtmlEmail email = new HtmlEmail(); try { // 这里是SMTP发送服务器的名字：163的如下：\"smtp.163.com\" email.setHostName(\"smtp.163.com\"); // 字符编码集的设置 email.setCharset(\"utf-8\"); // 收件人的邮箱 email.addTo(\"xxx@qq.com\"); // 发送人的邮箱2 email.setFrom(\"xxx@163.com\"); // 如果需要认证信息的话，设置认证：用户名-密码 ***是你开启POP3服务时的授权码，不是登录密码 email.setAuthentication(\"xxx\", \"xxx\"); // 要发送的邮件主题 email.setSubject(\"Test\"); // 要发送的信息，由于使用了HtmlEmail，可以在邮件内容中使用HTML标签 email.setMsg(\"&lt;img src='https://xxx.jpg'/&gt;\"); // 发送 email.send(); System.out.println(\"发送成功\"); } catch (EmailException e) { e.printStackTrace(); System.out.println(\"发送失败\"); } }} 有一说一，爽 感谢阅读","link":"/2019/11/22/Java-Mail/"},{"title":"在一台电脑上管理两个hexo博客","text":"出于个人原因，要在电脑上管理两个博客，这期间也是遇到了不少问题，也顺便把解决方法分享给大家 主要问题当你生成SSH添加到Github上时由于之前部署第一个博客时你可能输入了 123git config --global user.name &quot;yourname&quot;git config --global user.email &quot;youremail&quot;ssh-keygen -t rsa -C &quot;youremail&quot; 这里的global是全局设置，所以再次输入这两条指令，然后生成SSH，会覆盖之前一个博客的SSH，当你再对之前的博客进行hexo d时，就会报错 解决方法一、生成新的SSH先别输入git config…那两个指令先输入 12345ssh-keygen -t rsa -C &quot;your_new_email&quot; //然后gitbash里会这样Generating public/private rsa key pair. Enter file in which to save the key (/c/Users/you/.ssh/id_rsa): //这里输入新的id_rsa的名字，以便于和之前的id_rsa区分 这个新的SSH貌似没有出现在C盘的.ssh文件夹，而是出现在git bash的文件夹，所以你得把那两个id_rsa复制到.ssh文件夹 然后设置新Github的SSH key（将新的SSH添加到GitHub上） 三、添加新的 SSH 密钥到 SSH agent中12345ssh-add -D //如果出现Could not open a connection to your authentication agent//那就输入ssh-agent bashssh-add xxxxxx #旧密钥名称，一般是id_rsassh-add xxxxxx #新创建的密钥名称 四、取消全局配置12git config --global --unset user.namegit config --global --unset user.email 然后分别到两个博客文件里的.deploy_git文件夹下面右键git bash设置用户名和邮箱（其实当时处理第一个博客的时候，直接在.deploy_git文件夹下设置user.name和user.email,而不用全局设置，就OK）12git config user.name &quot;yourname&quot;git config user.email &quot;youremail&quot; 然后hexo clean hexo g hexo d 试一试 如果出现FATAL Something’s wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.html只需将_config.yml里的deploy部分仓库的地址改为https://yourname:yourpassword@github.com/yourname/yourname.github.io.git(你的GitHub用户名和密码) 至此就处理好了 感谢阅读","link":"/2019/06/17/hexo-2/"},{"title":"JAVA TCP编程","text":"TCP：Transmission Control Protocol 传输控制协议，面向连接的协议 两台机器之间可靠的，无差错的数据传输 双向字节流传递 服务器（软件服务器：能实现一定功能，在公开地址上对外服务）创建一个ServerSocket，等待连接 客户机：创建一个Socket，连接到服务器 服务器:ServerSocket接收到连接，创建一个Socket和客户的Socket创建专线连接，后续服务器和客户机的对话（这一对Socket）会在一个单独的线程（服务器端）上运行 服务器继续等待连接，返回步骤1 相关类 ServerSocket:服务器码头-需要绑定port-如果有多块网卡，需要绑定IP地址 Socket：运输通道-客户端绑定服务器的地址和端口-客户端往Socket输入流写入数据，送到服务端-客户端从Socket输出流取服务器端过来的地址-服务端则反之 注意事项 服务端等待响应时，处于阻塞状态 服务端可以同时响应多个客户端 服务端每接受一个客户端，就启动一个独立的线程与之对应 客户端与服务端都可以选择关闭这对Socket通道 代码演示 发送时间信息 简单回复（复读机） 解决中文乱码问题 使用PrintStream类 客户端1234567891011121314151617181920212223242526272829303132public class TcpClient { public static void main(String[] args) { try { Socket s = new Socket(InetAddress.getByName(\"127.0.0.1\"), 8001); InputStream ips = s.getInputStream(); //开启通道的输入流 BufferedReader brNet = new BufferedReader(new InputStreamReader(ips,StandardCharsets.UTF_8)); OutputStream ops = s.getOutputStream(); //开启通道的输出流 PrintStream ps = new PrintStream(ops, true, StandardCharsets.UTF_8); BufferedReader brKey = new BufferedReader(new InputStreamReader(System.in,StandardCharsets.UTF_8)); while (true) { String strword = brKey.readLine(); if (strword.equalsIgnoreCase(\"quit\")) { ps.println(strword); break; } else { ps.println(strword); System.out.println(\"服务端: \" + brNet.readLine()); } } brNet.close(); ps.close(); brKey.close(); } catch (Exception e) { e.printStackTrace(); } }} 服务端123456789101112131415public class TcpServer { public static void main(String[] args) { try { ServerSocket ss = new ServerSocket(8001); while (true) { Socket s = ss.accept(); System.out.println(\"连接成功\"); new Thread(new SendTime(s)).start(); } //ss.close(); } catch (Exception e) { e.printStackTrace(); } }} SendTime.java123456789101112131415161718192021222324252627282930313233public void run() { System.out.println(\"服务开始\"); try { InputStream ips = s.getInputStream(); OutputStream ops = s.getOutputStream(); BufferedReader br = new BufferedReader(new InputStreamReader(ips, StandardCharsets.UTF_8)); PrintStream ps = new PrintStream(ops, true, StandardCharsets.UTF_8); while (true) { String str = br.readLine(); System.out.println(\"客户端:\" + str); if (str.equalsIgnoreCase(\"quit\")) break; else { if (str.equalsIgnoreCase(\"time\")) { Date time = new Date(); SimpleDateFormat ft = new SimpleDateFormat(\"yyyy-MM-dd hh:mm:ss\"); ps.println(ft.format(time)); } else { String strEcho = str + \" 666\"; ps.println(strEcho); } } } br.close(); ps.close(); s.close(); } catch (Exception e) { e.printStackTrace(); }} 感谢阅读","link":"/2019/08/24/Java-TCP/"},{"title":"MATLAB学习笔记（一）","text":"一、使用简单命令求解线性方程$x_{1}+x_{2}=3$$x_{2}+x_{3}=4$$x_1+x_3=5$12345&gt;&gt;A=[1 1 0;0 1 1;1 0 1]&gt;&gt;B=[3;5;4]&gt;&gt;x=A\\B 二、MATLAB常用指令1234567&gt;&gt;logo %显示MATLAB三位图标&gt;&gt;version %显示版本号&gt;&gt;xpbombs %仿Windows系统自带的扫雷游戏&gt;&gt;lorenz %Lorenz吸引子动画显示 123456789&gt;&gt;who %变量&gt;&gt;whos %列出所有变量信息&gt;&gt;home %回到第一行&gt;&gt;help sum %求和函数的详细信息&gt;&gt;doc sum %以超文本的方式给出sum函数的信息 三、MATLAB内部常量、变量内部常量 inf 无穷大 pi 圆周率 exp(1) 自然对数的底数 NaN 没有意义的数 内部变量ans,date,clock,tic,toc123&gt;&gt;clock %依次为 年 月 日 时 分 秒&gt;&gt;tic %开始计时&gt;&gt;toc %停止计时 四、MATLAB中数组和矩阵的基本操作 矩阵是数组的子集。 数组中的元素可以是数字，字符等，矩阵中的只能是数12345678910111213141516171819202122标量（scalar） 1*1 向量（vector） 1*n或n*1 一维数组矩阵（matrix） m*n 高维数组x=[1 2 3] 行向量x=[1;2;3^2] 列向量y=[5:8] %y=[5 6 7 8]x=[1:0.5:5] %从1开始，以0.5为间隔，到5结束x=linspace(1,10,4) %从1开始，到10结束，包含4个元素x=(linspace(1,10,4))' %行向量转置为列向量x=[5 6 7;8 9 10] %将矩阵赋值给xx = 5 6 7 8 9 10 一些特殊矩阵及相关操作1.矩阵的创建123456789101112131415zeros(3) %3行3列的全0矩阵ones(3) %3行3列的全1矩阵eye(3) %单位矩阵rand(2) %2*2的随机矩阵magic(3) %3阶魔方矩阵 (行列对角线的和都相等)ans = 8 1 6 3 5 7 4 9 2 2.format long 和 format short的使用1234567891011121314151617format long %有效数字16位&gt;&gt; rand(3)ans = 0.964888535199277 0.957166948242946 0.141886338627215 0.157613081677548 0.485375648722841 0.421761282626275 0.970592781760616 0.800280468888800 0.915735525189067&gt;&gt; format short %有效数字4位&gt;&gt; rand(3)ans = 0.7922 0.0357 0.6787 0.9595 0.8491 0.7577 0.6557 0.9340 0.7431 3.end的使用12345678910111213data=[1 2 3;4 5 6;7 8 9]data = 1 2 3 4 5 6 7 8 9p=data(end-1,3)p = 6 4.读取操作 123456789101112131415161718192021222324252627282930313233data=[1 2 3;4 5 6;7 8 9]data = 1 2 3 4 5 6 7 8 9 x=data(2,:) %读取第二行x = 4 5 6&gt;&gt; x=data(:,2) %读取第二列x = 2 5 8x=data(1:2,:) %读取第一行到第二行的所有数x=data(1:2:4,:) %读取第一行 第三行 第五行的所有数row=data(:,end-1:end) %读取最后两列row = 2 3 5 6 8 9 5.写操作123data(3,:)=3 %将第三行所有数据都写为3data(1,1)=3 %将第一行第一列的数写为3","link":"/2019/09/04/MATLAB-1/"},{"title":"用树莓派搭建宿舍监控","text":"用树莓派搭建宿舍监控，好像没啥必要，就是买了个摄像头，先试着用一下，这个相当于是一个试水作品。 硬件平台：树莓派4B 腾讯云Centos7学生机 树莓派官方摄像头 环境搭建首先，我们需要把树莓派配置得方便使用，比如说这样四指滑动切换桌面其实还挺简单的，主要分两步 一、开启VNC 二、在VNC Viewer中访问树莓派桌面在自己的电脑上下载VNC Viewer，在地址栏里输入树莓派IP，之后会让你输入用户名和密码（就是pi和xxxx你自己设的密码），然后就可以了 三、frp内网穿透当然，要想内网穿透，得先来一个有公网IP的云服务器，我用的是腾讯云的学生机 云服务器配置1、在云服务器下载frp 12wget https://github.com/fatedier/frp/releases/download/v0.21.0/frp_0.21.0_linux_amd64.tar.gztar -xzvf frp_0.21.0_linux_amd64.tar.gz #解压 注意要删除和frpc相关的文件，只留下frps的相关文件2、配置frps.ini12cd frp_0.21.0_linux_amd64 sudo vim frps.ini 3、后台启动1nohup ./frps -c frps.ini &amp; #后台运行 树莓派frp配置1、下载frp我是直接去网站下载的，然后它在Download/文件夹下，解压完，删掉frps的相关文件即可2、配置frpc.ini12345678910111213sudo nano frpc.ini[common]server_addr = 你云服务器的IPserver_port = 7000 #先前绑定的端口login_fail_exit = false[ssh]type = tcplocal_ip = 127.0.0.1local_port = 5900 #VNC的端口remote_port =5900 #对应的云服务器的端口 3、后台运行1后台启动: nohup ./frpc -c ./frpc.ini &amp; 这样就可以在VNC Viewer里用公网IP来访问树莓派了 摄像头配置接入摄像头12sudo raspi-config# 进入选项5 Enable Camera motion配置1、安装motion1sudo apt-get install motion 2、motion配置1sudo vim /etc/motion/motion.conf 需要改写这些部分1234567stream_maxrate 200 提高传输速度width 800height 600framerate 100 开启motion1sudo motion 关闭监控1sudo killall -TERM motion 提醒：为了您的人身安全，请不要偷拍室友 感谢阅读","link":"/2019/12/03/用树莓派搭建宿舍监控/"},{"title":"用树莓派搭建路由器","text":"之所以会做这个，还是来于一位朋友的启发。宿舍的校园网能连接的设备有限，而且晚上宿舍断电不断网，有了树莓派，来个充电宝供电就可以整晚（等等，好像没有必要，晚上也就用个手机），我得说服一下自己……好了，我知道了，我想起来了，之前一直在玩ESP8266，这个东西连不了校园网，用树莓派把校园网信号分享出来，那么就又可以续上我的siri控制点灯了。 这个有很多方法，网上用的比较多的是hostapd，不过配置还挺烦的，对我这样的初学者不太友好，所以我选择用别人的脚本。还是菜。。。。。。 1.将create_ap文件拷贝到树莓派/home/pi文件目录下123git clone https://github.com/oblique/create_ap #将文件clone下来cd create_ap/ 安装create_ap123456#安裝命令sudo make install#更新软件源sudo apt-get update#安装依赖库sudo apt-get install util-linux procps hostapd iproute2 iw haveged dnsmasq 确保已经用连接了校园网，关于跳转到登陆界面的问题，可以通过访问http://www.baidu.com 来实现跳转一定得是http开头的网页，才能跳转 创建WIFI热点12#sudo create_ap wlan0 eth0 WIFI名 密码sudo create_ap wlan0 eth0 kcqnly-Raspberrypi 12345678 可以了 感谢阅读","link":"/2019/11/23/用树莓派搭建路由器/"}],"tags":[{"name":"ESP8266","slug":"ESP8266","link":"/tags/ESP8266/"},{"name":"MicroPython","slug":"MicroPython","link":"/tags/MicroPython/"},{"name":"物联网","slug":"物联网","link":"/tags/物联网/"},{"name":"CentOS","slug":"CentOS","link":"/tags/CentOS/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"MATLAB","slug":"MATLAB","link":"/tags/MATLAB/"},{"name":"树莓派","slug":"树莓派","link":"/tags/树莓派/"}],"categories":[{"name":"物联网","slug":"物联网","link":"/categories/物联网/"},{"name":"CentOS","slug":"CentOS","link":"/categories/CentOS/"},{"name":"Java","slug":"Java","link":"/categories/Java/"},{"name":"hexo","slug":"hexo","link":"/categories/hexo/"},{"name":"MATLAB","slug":"MATLAB","link":"/categories/MATLAB/"},{"name":"树莓派","slug":"树莓派","link":"/categories/树莓派/"}]}