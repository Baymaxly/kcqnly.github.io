{"pages":[{"title":"分类","text":"","link":"/categories/index.html"}],"posts":[{"title":"Git学习笔记","text":"1.在现有目录中初始化Git仓库 1git init 2.对文件的跟踪 1git add *.c 3.提交文件 12git commit -m &quot;message&quot;message为对本次提交的说明 4.掌握仓库当前的状态 1git status 5.查看不同 1git diff file-name 6.查看提交日志 1git log 7.版本回溯 1234git reset --hard HEAD^HEAD表示当前版本上一个版本就是HEAD^，上上一个版本就是HEAD^^当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。 8.查看命令历史 1234567git refloge475afc HEAD@{1}: reset: moving to HEAD^1094adb (HEAD -&gt; master) HEAD@{2}: commit: append GPLe475afc HEAD@{3}: commit: add distributedeaadf4e HEAD@{4}: commit (initial): wrote a readme file然后再使用git reset --hard 1094a就可以返回到append GPL的那个版本 9.丢弃工作区的修改 12git checkout -- filegit reset HEAD &lt;file&gt; 场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout – file。 场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD ，就回到了场景1，第二步按场景1操作。 场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。 10.删除文件 123git rm &lt;file&gt;如果误删了使用git checkout -- text.txt 可恢复 11.分支 123456git branch hexo 创建分支hexogit checkout hexo 切换到hexo分支git checkout -b hexo 创建并切换到hexo分支git merge hexo 将hexo分支合并到master分支git branch -d hexo 删除hexo分支git branch 查看分支","link":"/2019/07/06/Git学习笔记/"},{"title":"JAVA UDP编程","text":"UDP:无连接无状态的通信协议 发送方发送数据，如果接收方刚好在原地，则可以接收数据。如果不在，那么信息将丢失 发送方无法得知是否发送成功 简单，节省，经济 相关类DatagramSocket:通讯的数据管道 send和receive方法 绑定一个IP和Port DatagramPacket 集装箱：封装数据 地址：目的地IP+Port 代码实现一、实现单方面发送和接收发送端123456789101112131415161718192021222324import java.net.*;import java.util.Scanner;public class UdpSend { public static void main(String[] args) throws Exception { DatagramSocket ds = new DatagramSocket(); Scanner in = new Scanner(System.in); while(true) { String str = in.nextLine(); DatagramPacket dp = new DatagramPacket(str.getBytes(), str.getBytes().length, InetAddress.getByName(\"127.0.0.1\"), 3000); /*如果用str.length(),会出现中文乱码的问题。 将数据装到DatagramPacket时,英文字符是一个占一个字节, 而一个中文字符是占据两个字节,所以发送数据的长度如果用sendStr.length()计算, 英文字符不会出错,计算中文字符就会少计算了要发送的总字节数, 造成UDP服务端接收中文乱码*/ ds.send(dp); System.out.println(\"发送成功\"); if(str.equals(\"bye\")) return ; } }} 接收端12345678910111213141516171819import java.net.*;public class UdpRecv { public static void main(String[] args) throws Exception { DatagramSocket ds = new DatagramSocket(3000); byte[] buf = new byte[1024]; DatagramPacket dp = new DatagramPacket(buf, 1024); String strRecv; do { System.out.println(\"UdpRecv: 我在等待信息\"); ds.receive(dp); System.out.println(\"UdpRecv: 我接收到信息\"); strRecv = new String(dp.getData(), 0, dp.getLength()); System.out.println(strRecv); }while(!strRecv.equals(\"bye\")); ds.close(); }} 二、实现双向传输发送端12345678910111213141516171819202122232425262728import java.net.*;public class UdpSend{ public static void main(String [] args) throws Exception { DatagramSocket ds=new DatagramSocket();//建立通信管道 Scanner in = new Scanner(System.in); String str=in.nextLine(); DatagramPacket dp=new DatagramPacket(str.getBytes(),str.getBytes().length, InetAddress.getByName(\"127.0.0.1\"),3000); //127.0.0.1代表本机 System.out.println(\"UdpSend: 我要发送信息\"); ds.send(dp); System.out.println(\"UdpSend: 我发送信息结束\"); Thread.sleep(1000); byte [] buf=new byte[1024]; DatagramPacket dp2=new DatagramPacket(buf,1024); System.out.println(\"UdpSend: 我在等待信息\"); ds.receive(dp2); System.out.println(\"UdpSend: 我接收到信息\"); String str2=new String(dp2.getData(),0,dp2.getLength()) + \" from \" + dp2.getAddress().getHostAddress()+\":\"+dp2.getPort(); System.out.println(str2); ds.close(); }} 接收端12345678910111213141516171819202122232425262728import java.net.*;public class UdpRecv{ public static void main(String[] args) throws Exception { DatagramSocket ds=new DatagramSocket(3000); byte [] buf=new byte[1024]; DatagramPacket dp=new DatagramPacket(buf,1024); Scanner in = new Scanner(System.in); System.out.println(\"UdpRecv: 我在等待信息\"); ds.receive(dp); System.out.println(\"UdpRecv: 我接收到信息\"); String strRecv=new String(dp.getData(),0,dp.getLength()) + \" from \" + dp.getAddress().getHostAddress()+\":\"+dp.getPort(); System.out.println(strRecv); Thread.sleep(1000); System.out.println(\"UdpRecv: 我要发送信息\"); String str=in.nextLine(); DatagramPacket dp2=new DatagramPacket(str.getBytes(),str.length(), InetAddress.getByName(\"127.0.0.1\"),dp.getPort()); ds.send(dp2); System.out.println(\"UdpRecv: 我发送信息结束\"); ds.close(); }} 感谢阅读","link":"/2019/08/24/JAVA-UDP/"},{"title":"在一台电脑上管理两个hexo博客","text":"出于个人原因，要在电脑上管理两个博客，这期间也是遇到了不少问题，也顺便把解决方法分享给大家 主要问题当你生成SSH添加到Github上时由于之前部署第一个博客时你可能输入了 123git config --global user.name &quot;yourname&quot;git config --global user.email &quot;youremail&quot;ssh-keygen -t rsa -C &quot;youremail&quot; 这里的global是全局设置，所以再次输入这两条指令，然后生成SSH，会覆盖之前一个博客的SSH，当你再对之前的博客进行hexo d时，就会报错 解决方法一、生成新的SSH先别输入git config…那两个指令先输入 12345ssh-keygen -t rsa -C &quot;your_new_email&quot; //然后gitbash里会这样Generating public/private rsa key pair. Enter file in which to save the key (/c/Users/you/.ssh/id_rsa): //这里输入新的id_rsa的名字，以便于和之前的id_rsa区分 这个新的SSH貌似没有出现在C盘的.ssh文件夹，而是出现在git bash的文件夹，所以你得把那两个id_rsa复制到.ssh文件夹 然后设置新Github的SSH key（将新的SSH添加到GitHub上） 三、添加新的 SSH 密钥到 SSH agent中12345ssh-add -D //如果出现Could not open a connection to your authentication agent//那就输入ssh-agent bashssh-add xxxxxx #旧密钥名称，一般是id_rsassh-add xxxxxx #新创建的密钥名称 四、取消全局配置12git config --global --unset user.namegit config --global --unset user.email 然后分别到两个博客文件里的.deploy_git文件夹下面右键git bash设置用户名和邮箱（其实当时处理第一个博客的时候，直接在.deploy_git文件夹下设置user.name和user.email,而不用全局设置，就OK）12git config user.name &quot;yourname&quot;git config user.email &quot;youremail&quot; 然后hexo clean hexo g hexo d 试一试 如果出现FATAL Something’s wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.html只需将_config.yml里的deploy部分仓库的地址改为https://yourname:yourpassword@github.com/yourname/yourname.github.io.git(你的GitHub用户名和密码) 至此就处理好了 感谢阅读","link":"/2019/06/17/hexo-2/"},{"title":"更换电脑前后对原hexo博客的处理","text":"有时我们需要更换电脑或重装系统，这时就需要我们对hexo博客源文件进行备份 如果您不是很会用git,我建议您可以先选择用U盘拷贝，然后有时间的时候再好好学习一下git 一、 备份方法一 U盘拷贝并不是所有的文件都要拷贝，只需拷贝根目录下的 _config.yml package.json scaffolds/ source/ themes/ 方法二 分支管理 在本地先初始化git仓库 1git init 关联远程仓库1git remote add origin http://github.com/xxxxxx(你hexo博客的地址) 然后创建并切换到hexo分支1git checkout -b hexo 将文件放入暂存区，并推送到远程仓库 二、 安装hexo(别忘了安装Git和Node.js)鼠标右键Git Bash 输入 (以下指令皆在Git bash中输入)1npm install hexo-cli -g 三、 初始化文件夹1hexo init 然后将源文件直接复制过来方法二的朋友们就把指定分支上的文件clone下来就行1git clone -b 分支名 仓库地址 四、安装相应模块12npm instalnpm install hexo-deployer-git --save //将文章部署到git的模块 五、进行测试123hexo cleanhexo ghexo s 在浏览器输入http://localhost:4000 就能看到博客了 六、重新部署到GitHub上删除原先的SSH重新生成SSH添加到github就好了 12git config --global user.name &quot;yourname&quot;git config --global user.email &quot;youremail&quot; 用下面两个指令确认你有没有输对 12git config user.namegit config user.email 生成SSH(一路回车就OK) 1ssh-keygen -t rsa -C &quot;youremail&quot; 感谢阅读","link":"/2019/05/23/hexo(1)/"},{"title":"旅人","text":"自己写的第一首歌歌名：旅人我早已习惯孤独的生活就这样吧 无力改变了这就是我唯一要走的路啊人生至此 随遇而安吧背上行囊 就此出发害怕的东西依然害怕但可以面对喜欢的东西依旧喜欢但可以不拥有若不问过往和未来若不问悲欢和离合若不问理想和现实会轻松吗？无所谓了就这样吧不问过往不问未来不问悲欢不问离合不问理想不问现实不揭伤疤不惧流言啊 这里人来人往，喧嚣又宁静仰首是春，俯首是秋月圆如画，月缺如诗但我不会停留 在大雨中为你 撑伞的人啊在黑暗中默默 抱紧你的人啊 逗我笑的人 陪我哭的人和我聊天的人 来看我的人以我为重的人 想念我的人我不会遗忘","link":"/2019/06/19/旅人/"},{"title":"丢车","text":"第一辆车被偷今年三月份的时候，那辆陪伴我整个高三的永久山地车，被偷了。高三那会儿，我租住在学校旁边的学海公寓，虽说是公寓，但其实不过是将店面房硬生生拆成几间，供学生和家长居住。我住三楼，靠楼梯的那间房，每天都得通过一个只能容一人通过的狭小楼梯，才能回到这个温馨的临时住所。高三的生活很枯燥乏味，每天就是上课、自习、做题。高中生活就快到达尾声，我的成绩却没有什么起色。有时候真的很想出去走走，可能还是没有勇气吧，没有勇气走出平淡的日常。那段时间真的感觉很无助，下晚自习，我常常会骑着我那辆山地车，绕着虹鼎，骑上几圈，迟缓的骑行","link":"/2019/08/26/my-bike/"},{"title":"JAVA TCP编程","text":"TCP：Transmission Control Protocol 传输控制协议，面向连接的协议 两台机器之间可靠的，无差错的数据传输 双向字节流传递 服务器（软件服务器：能实现一定功能，在公开地址上对外服务）创建一个ServerSocket，等待连接 客户机：创建一个Socket，连接到服务器 服务器:ServerSocket接收到连接，创建一个Socket和客户的Socket创建专线连接，后续服务器和客户机的对话（这一对Socket）会在一个单独的线程（服务器端）上运行 服务器继续等待连接，返回步骤1 相关类 ServerSocket:服务器码头-需要绑定port-如果有多块网卡，需要绑定IP地址 Socket：运输通道-客户端绑定服务器的地址和端口-客户端往Socket输入流写入数据，送到服务端-客户端从Socket输出流取服务器端过来的地址-服务端则反之 注意事项 服务端等待响应时，处于阻塞状态 服务端可以同时响应多个客户端 服务端每接受一个客户端，就启动一个独立的线程与之对应 客户端与服务端都可以选择关闭这对Socket通道 代码演示 发送时间信息 简单回复（复读机） 解决中文乱码问题 使用PrintStream类 客户端1234567891011121314151617181920212223242526272829303132public class TcpClient { public static void main(String[] args) { try { Socket s = new Socket(InetAddress.getByName(\"127.0.0.1\"), 8001); InputStream ips = s.getInputStream(); //开启通道的输入流 BufferedReader brNet = new BufferedReader(new InputStreamReader(ips,StandardCharsets.UTF_8)); OutputStream ops = s.getOutputStream(); //开启通道的输出流 PrintStream ps = new PrintStream(ops, true, StandardCharsets.UTF_8); BufferedReader brKey = new BufferedReader(new InputStreamReader(System.in,StandardCharsets.UTF_8)); while (true) { String strword = brKey.readLine(); if (strword.equalsIgnoreCase(\"quit\")) { ps.println(strword); break; } else { ps.println(strword); System.out.println(\"服务端: \" + brNet.readLine()); } } brNet.close(); ps.close(); brKey.close(); } catch (Exception e) { e.printStackTrace(); } }} 服务端123456789101112131415public class TcpServer { public static void main(String[] args) { try { ServerSocket ss = new ServerSocket(8001); while (true) { Socket s = ss.accept(); System.out.println(\"连接成功\"); new Thread(new SendTime(s)).start(); } //ss.close(); } catch (Exception e) { e.printStackTrace(); } }} SendTime.java123456789101112131415161718192021222324252627282930313233public void run() { System.out.println(\"服务开始\"); try { InputStream ips = s.getInputStream(); OutputStream ops = s.getOutputStream(); BufferedReader br = new BufferedReader(new InputStreamReader(ips, StandardCharsets.UTF_8)); PrintStream ps = new PrintStream(ops, true, StandardCharsets.UTF_8); while (true) { String str = br.readLine(); System.out.println(\"客户端:\" + str); if (str.equalsIgnoreCase(\"quit\")) break; else { if (str.equalsIgnoreCase(\"time\")) { Date time = new Date(); SimpleDateFormat ft = new SimpleDateFormat(\"yyyy-MM-dd hh:mm:ss\"); ps.println(ft.format(time)); } else { String strEcho = str + \" 666\"; ps.println(strEcho); } } } br.close(); ps.close(); s.close(); } catch (Exception e) { e.printStackTrace(); }} 感谢阅读","link":"/2019/08/24/JAVA-TCP/"}],"tags":[{"name":"git","slug":"git","link":"/tags/git/"},{"name":"java","slug":"java","link":"/tags/java/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"MySongs","slug":"MySongs","link":"/tags/MySongs/"}],"categories":[{"name":"java","slug":"java","link":"/categories/java/"}]}