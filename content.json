{"pages":[{"title":"分类","text":"","link":"/categories/index.html"}],"posts":[{"title":"JAVA UDP编程","text":"UDP:无连接无状态的通信协议 发送方发送数据，如果接收方刚好在原地，则可以接收数据。如果不在，那么信息将丢失 发送方无法得知是否发送成功 简单，节省，经济 相关类DatagramSocket:通讯的数据管道 send和receive方法 绑定一个IP和Port DatagramPacket 集装箱：封装数据 地址：目的地IP+Port 代码实现一、实现单方面发送和接收发送端123456789101112131415161718192021222324import java.net.*;import java.util.Scanner;public class UdpSend { public static void main(String[] args) throws Exception { DatagramSocket ds = new DatagramSocket(); Scanner in = new Scanner(System.in); while(true) { String str = in.nextLine(); DatagramPacket dp = new DatagramPacket(str.getBytes(), str.getBytes().length, InetAddress.getByName(\"127.0.0.1\"), 3000); /*如果用str.length(),会出现中文乱码的问题。 将数据装到DatagramPacket时,英文字符是一个占一个字节, 而一个中文字符是占据两个字节,所以发送数据的长度如果用sendStr.length()计算, 英文字符不会出错,计算中文字符就会少计算了要发送的总字节数, 造成UDP服务端接收中文乱码*/ ds.send(dp); System.out.println(\"发送成功\"); if(str.equals(\"bye\")) return ; } }} 接收端12345678910111213141516171819import java.net.*;public class UdpRecv { public static void main(String[] args) throws Exception { DatagramSocket ds = new DatagramSocket(3000); byte[] buf = new byte[1024]; DatagramPacket dp = new DatagramPacket(buf, 1024); String strRecv; do { System.out.println(\"UdpRecv: 我在等待信息\"); ds.receive(dp); System.out.println(\"UdpRecv: 我接收到信息\"); strRecv = new String(dp.getData(), 0, dp.getLength()); System.out.println(strRecv); }while(!strRecv.equals(\"bye\")); ds.close(); }} 二、实现双向传输发送端12345678910111213141516171819202122232425262728import java.net.*;public class UdpSend{ public static void main(String [] args) throws Exception { DatagramSocket ds=new DatagramSocket();//建立通信管道 Scanner in = new Scanner(System.in); String str=in.nextLine(); DatagramPacket dp=new DatagramPacket(str.getBytes(),str.getBytes().length, InetAddress.getByName(\"127.0.0.1\"),3000); //127.0.0.1代表本机 System.out.println(\"UdpSend: 我要发送信息\"); ds.send(dp); System.out.println(\"UdpSend: 我发送信息结束\"); Thread.sleep(1000); byte [] buf=new byte[1024]; DatagramPacket dp2=new DatagramPacket(buf,1024); System.out.println(\"UdpSend: 我在等待信息\"); ds.receive(dp2); System.out.println(\"UdpSend: 我接收到信息\"); String str2=new String(dp2.getData(),0,dp2.getLength()) + \" from \" + dp2.getAddress().getHostAddress()+\":\"+dp2.getPort(); System.out.println(str2); ds.close(); }} 接收端12345678910111213141516171819202122232425262728import java.net.*;public class UdpRecv{ public static void main(String[] args) throws Exception { DatagramSocket ds=new DatagramSocket(3000); byte [] buf=new byte[1024]; DatagramPacket dp=new DatagramPacket(buf,1024); Scanner in = new Scanner(System.in); System.out.println(\"UdpRecv: 我在等待信息\"); ds.receive(dp); System.out.println(\"UdpRecv: 我接收到信息\"); String strRecv=new String(dp.getData(),0,dp.getLength()) + \" from \" + dp.getAddress().getHostAddress()+\":\"+dp.getPort(); System.out.println(strRecv); Thread.sleep(1000); System.out.println(\"UdpRecv: 我要发送信息\"); String str=in.nextLine(); DatagramPacket dp2=new DatagramPacket(str.getBytes(),str.length(), InetAddress.getByName(\"127.0.0.1\"),dp.getPort()); ds.send(dp2); System.out.println(\"UdpRecv: 我发送信息结束\"); ds.close(); }} 感谢阅读","link":"/2019/08/24/JAVA-UDP/"},{"title":"MATLAB学习笔记（一）","text":"一、使用简单命令求解线性方程$x_{1}+x_{2}=3$$x_{2}+x_{3}=4$$x_1+x_3=5$12345&gt;&gt;A=[1 1 0;0 1 1;1 0 1]&gt;&gt;B=[3;5;4]&gt;&gt;x=A\\B 二、MATLAB常用指令1234567&gt;&gt;logo //显示MATLAB三位图标&gt;&gt;version //显示版本号&gt;&gt;xpbombs //仿Windows系统自带的扫雷游戏&gt;&gt;lorenz //Lorenz吸引子动画显示 123456789&gt;&gt;who //变量&gt;&gt;whos //列出所有变量信息&gt;&gt;home //回到第一行&gt;&gt;help sum //求和函数的详细信息&gt;&gt;doc sum //以超文本的方式给出sum函数的信息 三、MATLAB内部常量、变量内部常量 inf 无穷大 pi 圆周率 exp(1) 自然对数的底数 NaN 没有意义的数 内部变量ans,date,clock,tic,toc123&gt;&gt;clock //依次为 年 月 日 时 分 秒&gt;&gt;tic //开始计时&gt;&gt;toc //停止计时 四、MATLAB中数组和矩阵的基本操作 矩阵是数组的子集。 数组中的元素可以是数字，字符等，矩阵中的只能是数12345678910111213141516171819202122标量（scalar） 1*1 向量（vector） 1*n或n*1 一维数组矩阵（matrix） m*n 高维数组x=[1 2 3] 行向量x=[1;2;3^2] 列向量y=[5:8] //y=[5 6 7 8]x=[1:0.5:5] //从1开始，以0.5为间隔，到5结束x=linspace(1,10,4) //从1开始，到10结束，包含4个元素x=(linspace(1,10,4))' //行向量转置为列向量x=[5 6 7;8 9 10] //将矩阵赋值给xx = 5 6 7 8 9 10 一些特殊矩阵及相关操作1.矩阵的创建123456789101112131415zeros(3) //3行3列的全0矩阵ones(3) //3行3列的全1矩阵eye(3) //单位矩阵rand(2) //2*2的随机矩阵magic(3) //3阶魔方矩阵 (行列对角线的和都相等)ans = 8 1 6 3 5 7 4 9 2 2.format long 和 format short的使用1234567891011121314151617format long //有效数字16位&gt;&gt; rand(3)ans = 0.964888535199277 0.957166948242946 0.141886338627215 0.157613081677548 0.485375648722841 0.421761282626275 0.970592781760616 0.800280468888800 0.915735525189067&gt;&gt; format short//有效数字4位&gt;&gt; rand(3)ans = 0.7922 0.0357 0.6787 0.9595 0.8491 0.7577 0.6557 0.9340 0.7431 3.end的使用12345678910111213data=[1 2 3;4 5 6;7 8 9]data = 1 2 3 4 5 6 7 8 9p=data(end-1,3)p = 6 4.读取操作 123456789101112131415161718192021222324252627282930313233data=[1 2 3;4 5 6;7 8 9]data = 1 2 3 4 5 6 7 8 9 x=data(2,:)//读取第二行x = 4 5 6&gt;&gt; x=data(:,2)//读取第二列x = 2 5 8x=data(1:2,:) //读取第一行到第二行的所有数x=data(1:2:4,:)//读取第一行 第三行 第五行的所有数row=data(:,end-1:end)//读取最后两列row = 2 3 5 6 8 9 5.写操作123data(3,:)=3//将第三行所有数据都写为3data(1,1)=3 //将第一行第一列的数写为3","link":"/2019/09/04/MATLAB-1/"},{"title":"Git学习笔记","text":"1.在现有目录中初始化Git仓库 1git init 2.对文件的跟踪 1git add *.c 3.提交文件 12git commit -m &quot;message&quot;message为对本次提交的说明 4.掌握仓库当前的状态 1git status 5.查看不同 1git diff file-name 6.查看提交日志 1git log 7.版本回溯 1234git reset --hard HEAD^HEAD表示当前版本上一个版本就是HEAD^，上上一个版本就是HEAD^^当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。 8.查看命令历史 1234567git refloge475afc HEAD@{1}: reset: moving to HEAD^1094adb (HEAD -&gt; master) HEAD@{2}: commit: append GPLe475afc HEAD@{3}: commit: add distributedeaadf4e HEAD@{4}: commit (initial): wrote a readme file然后再使用git reset --hard 1094a就可以返回到append GPL的那个版本 9.丢弃工作区的修改 12git checkout -- filegit reset HEAD &lt;file&gt; 场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout – file。 场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD ，就回到了场景1，第二步按场景1操作。 场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。 10.删除文件 123git rm &lt;file&gt;如果误删了使用git checkout -- text.txt 可恢复 11.分支 123456git branch hexo 创建分支hexogit checkout hexo 切换到hexo分支git checkout -b hexo 创建并切换到hexo分支git merge hexo 将hexo分支合并到master分支git branch -d hexo 删除hexo分支git branch 查看分支","link":"/2019/07/06/Git学习笔记/"},{"title":"在一台电脑上管理两个hexo博客","text":"出于个人原因，要在电脑上管理两个博客，这期间也是遇到了不少问题，也顺便把解决方法分享给大家 主要问题当你生成SSH添加到Github上时由于之前部署第一个博客时你可能输入了 123git config --global user.name &quot;yourname&quot;git config --global user.email &quot;youremail&quot;ssh-keygen -t rsa -C &quot;youremail&quot; 这里的global是全局设置，所以再次输入这两条指令，然后生成SSH，会覆盖之前一个博客的SSH，当你再对之前的博客进行hexo d时，就会报错 解决方法一、生成新的SSH先别输入git config…那两个指令先输入 12345ssh-keygen -t rsa -C &quot;your_new_email&quot; //然后gitbash里会这样Generating public/private rsa key pair. Enter file in which to save the key (/c/Users/you/.ssh/id_rsa): //这里输入新的id_rsa的名字，以便于和之前的id_rsa区分 这个新的SSH貌似没有出现在C盘的.ssh文件夹，而是出现在git bash的文件夹，所以你得把那两个id_rsa复制到.ssh文件夹 然后设置新Github的SSH key（将新的SSH添加到GitHub上） 三、添加新的 SSH 密钥到 SSH agent中12345ssh-add -D //如果出现Could not open a connection to your authentication agent//那就输入ssh-agent bashssh-add xxxxxx #旧密钥名称，一般是id_rsassh-add xxxxxx #新创建的密钥名称 四、取消全局配置12git config --global --unset user.namegit config --global --unset user.email 然后分别到两个博客文件里的.deploy_git文件夹下面右键git bash设置用户名和邮箱（其实当时处理第一个博客的时候，直接在.deploy_git文件夹下设置user.name和user.email,而不用全局设置，就OK）12git config user.name &quot;yourname&quot;git config user.email &quot;youremail&quot; 然后hexo clean hexo g hexo d 试一试 如果出现FATAL Something’s wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.html只需将_config.yml里的deploy部分仓库的地址改为https://yourname:yourpassword@github.com/yourname/yourname.github.io.git(你的GitHub用户名和密码) 至此就处理好了 感谢阅读","link":"/2019/06/17/hexo-2/"},{"title":"更换电脑前后对原hexo博客的处理","text":"有时我们需要更换电脑或重装系统，这时就需要我们对hexo博客源文件进行备份 如果您不是很会用git,我建议您可以先选择用U盘拷贝，然后有时间的时候再好好学习一下git 一、 备份方法一 U盘拷贝并不是所有的文件都要拷贝，只需拷贝根目录下的 _config.yml package.json scaffolds/ source/ themes/ 方法二 分支管理 在本地先初始化git仓库 1git init 关联远程仓库1git remote add origin http://github.com/xxxxxx(你hexo博客的地址) 然后创建并切换到hexo分支1git checkout -b hexo 将文件放入暂存区，并推送到远程仓库 二、 安装hexo(别忘了安装Git和Node.js)鼠标右键Git Bash 输入 (以下指令皆在Git bash中输入)1npm install hexo-cli -g 三、 初始化文件夹1hexo init 然后将源文件直接复制过来方法二的朋友们就把指定分支上的文件clone下来就行1git clone -b 分支名 仓库地址 四、安装相应模块12npm instalnpm install hexo-deployer-git --save //将文章部署到git的模块 五、进行测试123hexo cleanhexo ghexo s 在浏览器输入http://localhost:4000 就能看到博客了 六、重新部署到GitHub上删除原先的SSH重新生成SSH添加到github就好了 12git config --global user.name &quot;yourname&quot;git config --global user.email &quot;youremail&quot; 用下面两个指令确认你有没有输对 12git config user.namegit config user.email 生成SSH(一路回车就OK) 1ssh-keygen -t rsa -C &quot;youremail&quot; 感谢阅读","link":"/2019/05/23/hexo(1)/"},{"title":"CentOS7安装jdk12","text":"卸载openjdk查找已安装的java包1rpm -qa | grep java 删除已安装的java1234rpm -e --nodeps java-1.8.0-openjdk-1.8.0.102-4.b14.el7.x86_64rpm -e --nodeps java-1.8.0-openjdk-headless-1.8.0.102-4.b14.el7.x86_64rpm -e --nodeps java-1.7.0-openjdk-headless-1.7.0.111-2.6.7.8.el7.x86_64rpm -e --nodeps java-1.7.0-openjdk-1.7.0.111-2.6.7.8.el7.x86_64 下载JDK12压缩包 点击这里开始下载 安装##创建安装目录1mkdir /usr/local/java/ 上传文件至安装目录1rz 然后选择要上传的文件如果有xftp，那就更方便了 解压至安装目录1tar -xzvf jdk-12.0.2-linux-x64-bin.tar.gz -C /usr/local/java/ 设置环境变量打开文件1vim /etc/profile 修改文件按i进入编辑模式在末尾添加1234export JAVA_HOME=/usr/local/java/jdk12.0.2export JRE_HOME=${JAVA_HOME}/jreexport CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/libexport PATH=${JAVA_HOME}/bin:$PATH 保存更改 Linux相关保存命令按ESC键 跳到命令模式，然后： :w 保存文件但不退出vi :w file 将修改另外保存到file中，不退出vi :w! 强制保存，不推出vi :wq 保存文件并退出vi :wq! 强制保存文件，并退出vi :q 不保存文件，退出vi :q! 不保存文件，强制退出vi :e! 放弃所有修改，从上次保存文件开始再编辑 1:wq 使环境变量生效1source /etc/profile 添加软链接1ln -s /usr/local/java/jdk12.0.2/bin/java /usr/bin/java 检查1java -version 删除压缩包12cd /rootrm -rf jdk-12.0.2-linux-x64-bin.tar.gz","link":"/2019/09/13/Centos7安装jdk12/"},{"title":"JAVA TCP编程","text":"TCP：Transmission Control Protocol 传输控制协议，面向连接的协议 两台机器之间可靠的，无差错的数据传输 双向字节流传递 服务器（软件服务器：能实现一定功能，在公开地址上对外服务）创建一个ServerSocket，等待连接 客户机：创建一个Socket，连接到服务器 服务器:ServerSocket接收到连接，创建一个Socket和客户的Socket创建专线连接，后续服务器和客户机的对话（这一对Socket）会在一个单独的线程（服务器端）上运行 服务器继续等待连接，返回步骤1 相关类 ServerSocket:服务器码头-需要绑定port-如果有多块网卡，需要绑定IP地址 Socket：运输通道-客户端绑定服务器的地址和端口-客户端往Socket输入流写入数据，送到服务端-客户端从Socket输出流取服务器端过来的地址-服务端则反之 注意事项 服务端等待响应时，处于阻塞状态 服务端可以同时响应多个客户端 服务端每接受一个客户端，就启动一个独立的线程与之对应 客户端与服务端都可以选择关闭这对Socket通道 代码演示 发送时间信息 简单回复（复读机） 解决中文乱码问题 使用PrintStream类 客户端1234567891011121314151617181920212223242526272829303132public class TcpClient { public static void main(String[] args) { try { Socket s = new Socket(InetAddress.getByName(\"127.0.0.1\"), 8001); InputStream ips = s.getInputStream(); //开启通道的输入流 BufferedReader brNet = new BufferedReader(new InputStreamReader(ips,StandardCharsets.UTF_8)); OutputStream ops = s.getOutputStream(); //开启通道的输出流 PrintStream ps = new PrintStream(ops, true, StandardCharsets.UTF_8); BufferedReader brKey = new BufferedReader(new InputStreamReader(System.in,StandardCharsets.UTF_8)); while (true) { String strword = brKey.readLine(); if (strword.equalsIgnoreCase(\"quit\")) { ps.println(strword); break; } else { ps.println(strword); System.out.println(\"服务端: \" + brNet.readLine()); } } brNet.close(); ps.close(); brKey.close(); } catch (Exception e) { e.printStackTrace(); } }} 服务端123456789101112131415public class TcpServer { public static void main(String[] args) { try { ServerSocket ss = new ServerSocket(8001); while (true) { Socket s = ss.accept(); System.out.println(\"连接成功\"); new Thread(new SendTime(s)).start(); } //ss.close(); } catch (Exception e) { e.printStackTrace(); } }} SendTime.java123456789101112131415161718192021222324252627282930313233public void run() { System.out.println(\"服务开始\"); try { InputStream ips = s.getInputStream(); OutputStream ops = s.getOutputStream(); BufferedReader br = new BufferedReader(new InputStreamReader(ips, StandardCharsets.UTF_8)); PrintStream ps = new PrintStream(ops, true, StandardCharsets.UTF_8); while (true) { String str = br.readLine(); System.out.println(\"客户端:\" + str); if (str.equalsIgnoreCase(\"quit\")) break; else { if (str.equalsIgnoreCase(\"time\")) { Date time = new Date(); SimpleDateFormat ft = new SimpleDateFormat(\"yyyy-MM-dd hh:mm:ss\"); ps.println(ft.format(time)); } else { String strEcho = str + \" 666\"; ps.println(strEcho); } } } br.close(); ps.close(); s.close(); } catch (Exception e) { e.printStackTrace(); }} 感谢阅读","link":"/2019/08/24/JAVA-TCP/"}],"tags":[{"name":"java","slug":"java","link":"/tags/java/"},{"name":"MATLAB","slug":"MATLAB","link":"/tags/MATLAB/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"CentOS","slug":"CentOS","link":"/tags/CentOS/"}],"categories":[{"name":"java","slug":"java","link":"/categories/java/"}]}